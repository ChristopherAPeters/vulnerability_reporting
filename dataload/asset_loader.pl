#!/usr/bin/perl -w

#
# Parse CSV file with Qualys vulnerability and/or Bitsight data and populate asset/vuln tables.
#
# Author:  Chris Peters, PGi  2021
#
# Inputs:  takes one command line argument, with "-i" flag:  location of CSV file with either Qualys or Bitsight vulns in CSV format
# Optional:  "-b" flag denotes that the CSV file is in the bitsight format.  The default mode is to assume Qualys.
#
# Debug:  to get useful debuggin output change the line "use constant DEBUG=>0" to "use constant DEBUG=>1"
# Outputs:  
# 		STDOUT number of database rows updated/inserted
# 		STDERR any error messages 

use strict;
use warnings;
use Getopt::Std;
use DBI;
use Text::CSV;
use Data::Dumper;
use Socket;
use Time::Date;
use Date::Manip::Date;

use constant DEBUG=>1;

our ($opt_b, $opt_g, $opt_h,$opt_i, $opt_o, $opt_u, $opt_p);
getopts("bghi:o:p:u:");

#

my $owner = "Unknown";
if (defined($opt_o)) {
    #code
    $owner = $opt_o;
}
my ($username, $pwd) = ($opt_u, $opt_p);
my $href=getGroups($username, $pwd); #pulls a list of valid owner groups from DB

if (defined($opt_h))
{
   print "Usage:  $0 -i<input CSV report qualys/bitsight> -b<parse bitsight> -o<owner group> -u<DB username> -p<DB password>\n";
   print "OR:\n";
   print "Usage:  $0 -g <display valid owner groups>\n";
   print "\n\nList of valid owner groups:\n\n";
   print Dumper $href;
   exit 0;

}
if (defined($opt_g)) {
    	print "List of valid owner groups:\n\n";
	print Dumper $href;
	exit 0;
}
if (!defined($opt_i))
{
        die "Usage: $0 -i<CSV input file> -b<parse bitsight format>\n";
}
#my %ownerIDs = ("Canada" => 1, "GlobalSysAdmin" => 2, "iMeetCentral" => 3, "Marketing" =>4, "ReadyTalk" => 5,
#                "Webcasts" => 6, "GM Audio" => 7, "Unknown" => 8, "Networks" => 9);
#
my %ownerIDs= %{$href};
    
open my $fh, "<", $opt_i or die "$opt_i: $!";

#1. Parse out Csv FILE
my $csv = Text::CSV->new({binary => 1, auto_diag => 1 });

my $assets = {}; # need hash of hashes to store assets?


my $first = 0;
while(my $row = $csv->getline($fh))
{
    next unless ($first++);
    
    my ($ip, $dns, $netBIOS, $tracking, $os, $ip_status, $qid, $title, $vulnStatus,
        $type, $severity, $port, $protocol, $FQDN, $ssl, $firstDetected, $lastDetected, $timesDetected,
        $dateLastFixed, $CVE, $vendorReference, $bugtraqID, $threat, $impact, $solution, $exploitability,
        $malware, $results,$pciVuln, $ticketState,$instance,$category);
    if ($opt_b)
    {
        my ($risk,$identifier,$remediationStatus,$statusUpdated, $assigned, $firstSeen,$lastSeen,$grade, $impacts,
            $remainingLifetime, $attributedTo, $severity,$title,$solution,$comment, $vulnerability, $type, $version, $tags,
            $refresh) = @{$row};
        
        # here comes fun part ... bitsight identifier can be an IP, and IP:Port combo, or just a DNS name ... need to disambiguate this
        
        if (defined($identifier) and length($identifier)> 2 )
        {
         $ip=processIdentifier($identifier, 1);
         $dns=processIdentifier($identifier, 2);
         $port = processIdentifier($identifier, 3);
         $vulnStatus=$remediationStatus;
         $qid=$title;
         $firstDetected = $firstSeen;
          $lastDetected = $lastSeen;
        }
            
        #code
    } else {  
    
        ($ip, $dns, $netBIOS, $tracking, $os, $ip_status, $qid, $title, $vulnStatus,
        $type, $severity, $port, $protocol, $FQDN, $ssl, $firstDetected, $lastDetected, $timesDetected,
        $dateLastFixed, $CVE, $vendorReference, $bugtraqID, $threat, $impact, $solution, $exploitability,
        $malware, $results,$pciVuln, $ticketState,$instance,$category) = @{$row};
    
        if (length($ip) > 17)
        { # need to check for garbage values.
	    	print "Unusual IP found at line $first: $ip\n";
         print "Skipping this row\n";
         next;
        }
    }
    
    if (!defined($ip)) {
        next; 
        #if for some reason IP is not defined, we have to skip this record as there is no key ...
    }
    
    $assets->{$ip}->{DNSname}=$dns;
    $assets->{$ip}->{OS}=$os;
    $assets->{$ip}->{firstSeen}=$firstDetected;
    $assets->{$ip}->{lastSeen}=$lastDetected;
    $assets->{$ip}->{hostname}=$netBIOS;
    
   #push ($assets->{$ip}->{vulnerabilities},"$qid");
    my $arrayref= $assets->{$ip}->{vulnerabilities};
    if (!defined($arrayref)) {
        $assets->{$ip}->{vulnerabilities}= [];  # initialize it w. an anonymous array
    }
    my $delimiter=":";
    $delimiter = "|" if ($opt_b);
    push (@{$assets->{$ip}->{vulnerabilities}}, "$qid$delimiter$port$delimiter$vulnStatus");
    
    
}

close $fh;

print "Processed $first records owner=$owner\n";


loadAssetData($assets, $username, $pwd);

print Dumper $assets if DEBUG;

if ($opt_b)
{
	loadAssetVulnData($assets, $username, $pwd, 2);
} else {
	loadAssetVulnData($assets, $username, $pwd, 1);
}

sub processIdentifier
{
    my $identifier = shift;
    my $recordType = shift;
    my $dnsname;
    
        #parse identifier and return IP address
        my ($ip,$port) = split/:/,$identifier;
        if (!defined($port) || $port !~/\d+$/)
        {
            $port = 0;
        }
        if ($ip =~ /^\d+\.\d+\.\d+\.\d+$/)
        {
           #Ip good
           print "Got good ip: $ip\n" if DEBUG;
        } elsif ($ip =~ /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/) { # it might be a DNS name ... try to parse it as such
            $dnsname = $ip;
            my $addr = inet_aton($dnsname);
            if (!$addr) {
                #unparsable for some reason ... give up!
                $ip = undef;
            } else {
            
                $ip = inet_ntoa($addr);
            }
        } else { # unparse-able}
            $dnsname = undef;
            $ip = undef;
        }
   if ($recordType == 1) {
    return $ip;
   }
   if ($recordType == 2) {
    return $dnsname;
   }
   if ($recordType == 3) {
    return $port;
   }

    
}
 
sub loadAssetVulnData
{
    
    my $assets = shift;
    my $dbuser = shift;
    my $dbpass = shift;
    my $datasource = shift;
    my $sql_select_query;
    my $delimiter;
    my %vulnStatus ;
    if ($datasource == 1)
    {
    	 $sql_select_query = qq/select a.AssetID, v.VulnerabilityID from ASSETS a, VULNERABILITY v where v.QualysID= ? and a.IPAddress = ? and a.ownerID = ?/;
       %vulnStatus = ( Active => 1, Fixed => 2, New => 3, "Re-Opened" => 4);   # qualys status
	    $delimiter=":";
    } elsif ($datasource == 2)
    {
    	$sql_select_query = qq/select a.AssetID, v.VulnerabilityID from ASSETS a, VULNERABILITY v where v.VulnerabilityID= ? and a.IPAddress = ? and a.ownerID = ?/;
	   $delimiter="|";
      %vulnStatus = ( Open => 1, Resolved => 2, "Work In Progress" => 3, "To Do" => 4, "Risk Accepted" => 5);
    }
   
    my $sql_update_query = qq/update ASSETVULNERABILITY set LAST_SEEN = ?, StatusID=? where ASSET_ID = ? and VULNERABILITY_ID = ? and Port = ?/;
    # Todo:  update the query below to add the statusID
    my $sql_insert_query = qq/insert into ASSETVULNERABILITY (Asset_ID,VULNERABILITY_ID,FIRST_SEEN, LAST_SEEN, PORT, StatusID) values (?,?,?,?,?,?)/;
    my $dbname = "VULNMGMT_DB";
    my $dbh =  DBI->connect("DBI:mysql:database=$dbname;host=localhost", $dbuser, $dbpass, { RaiseError =>1, AutoCommit => 0}) ;
    my $sth_select = $dbh->prepare_cached($sql_select_query);
    my $sth_update = $dbh->prepare_cached($sql_update_query);
    my $sth_insert = $dbh->prepare_cached($sql_insert_query);
    my $rows_inserted = 0;
    my $statusID;
    foreach my $asset (keys %{$assets})
    {
        foreach my $vuln (@{$assets->{$asset}->{vulnerabilities}})
        {
          my ($qid,$port,$textStatus) = split/\Q$delimiter/,$vuln;
          print "QID = $qid port = $port\n" if DEBUG;
          if (!defined($port) || $port !~/\d+$/)
          {
               $port = 0;
          }
          if (!defined($textStatus)) {
            $statusID = undef;
          } else {
            $statusID = $vulnStatus{$textStatus};
          }
          
          $sth_select->execute($qid, $asset, $ownerIDs{$owner});
          my ($assetID, $vulnID) = $sth_select->fetchrow_array();
          my $lastSeen = $assets->{$asset}->{lastSeen};
          #print "asset=$asset QID = $qid, port = $port vuln= $vuln status= $textStatus lastSeen=$lastSeen\n" if DEBUG;
          print ("asset=$asset QID = $qid, port = $port assetID = $assetID, vulnID= $vulnID, vuln= $vuln status= $textStatus lastSeen=$lastSeen\n") if DEBUG;
           
	# Time to do the needful ...
	# Try an update query first to see if we already have a asset/vulnerability/port triplet in the DB
         my $rows_updated=0;
         eval {
		    $sth_update->execute($assets->{$asset}->{lastSeen}, $statusID, $assetID, $vulnID, $port);
		    $rows_updated= $sth_update->rows;
		    $dbh->commit;
         };
         if ($@)
         {
          warn "Trapped DB error: $@";
          $dbh->rollback;
         }
         if ($rows_updated)
         {
		    	print "Updated $rows_updated rows\n";

         } else {
            print "attempting to insert new asset vulnerability data:  $assetID, $vulnID, $port\n" if DEBUG;
            eval {
			    $sth_insert->execute($assetID,$vulnID,$assets->{$asset}->{firstSeen},$assets->{$asset}->{lastSeen},$port,$statusID);
			    $dbh->commit;
			    $rows_inserted++;
            };
            if ($@)
            {
               warn "Trapped DB error: $@";
               $dbh->rollback;
            }

         }
        }
        $sth_select->finish();
#       $sth_update->finish();
#        $sth_insert->finish();
        print "Inserted $rows_inserted new rows of asset vulnerabilties\n";
	
    }
    $dbh->disconnect();
}
#
sub loadAssetData {
    
        my $assets = shift;
        my $dbuser = shift;
        my $dbpass = shift;
        
        my $sql_update_query = qq/update ASSETS set LastSeen = ? where IPAddress = ? AND ownerID= ?/;
        my $sql_insert_query = qq/insert into ASSETS (IPAddress, DNSName, Hostname, ownerID, FirstSeen, LastSeen, OSName) values (?,?,?,?,?,?,?)/;
        my $dbname = "VULNMGMT_DB";
        my $dbh =  DBI->connect("DBI:mysql:database=$dbname;host=localhost", $dbuser, $dbpass, { RaiseError =>1, AutoCommit => 0}) ;
        my $sth_update = $dbh->prepare_cached($sql_update_query);
        my $sth_insert = $dbh->prepare_cached($sql_insert_query);
	     my $rows_inserted=0;
        foreach my $asset (keys %{$assets})
        {
            
            # Now remember, the asset may already exist in the table.  Thus we have to try an update query first.
            # If that fails, then it is new and can be an INSERT
            my ($firstSeen, $lastSeen, $dataLoadDate);
            my $date= new Date::Manip::Date;
            my $err = $date->parse($assets->{$asset}->{firstSeen});
            if ($err)
            {
                print "Error parsing first_seen:  $assets->{$asset}->{firstSeen}\n";
                $firstSeen = undef;
            } else {
                $firstSeen = $date->printf("%Y-%m-%d");
                $assets->{$asset}->{firstSeen}=$firstSeen;
            }
            $err = $date->parse($assets->{$asset}->{lastSeen});
            if ($err)
            {
                print "Error parsing last_seen:  $assets->{$asset}->{lastSeen}\n";
                $lastSeen = undef;
            } else {
                $lastSeen = $date->printf("%Y-%m-%d");
                 $assets->{$asset}->{lastSeen}=$lastSeen;
            }
            my $rows_updated;
            eval {
            	print "Asset = $asset owner= $ownerIDs{$owner}	trying to update table\n";
                $sth_update->execute($lastSeen, $asset, $ownerIDs{$owner});
            	$rows_updated = $sth_update->rows;
                $dbh->commit;
                };
            if ($@) {
                warn "Trapped db error: $@";
                $dbh->rollback;
            }
            if ($rows_updated) {
               print "Updated $rows_updated rows\n";
            } else { # found a new one
               eval { 
                $sth_insert->execute($asset, $assets->{$asset}->{DNSname}, $assets->{$asset}->{hostname}, $ownerIDs{$owner},
                                     $firstSeen,$lastSeen, $assets->{$asset}->{OS});
                $dbh->commit;
		$rows_inserted++;
               };
               if ($@) {
                #warn "Trapped db error: $@";
                $dbh->rollback;
               }
               
            }
            $sth_update->finish;
            $sth_insert->finish;
            
	    print "Inserted $rows_inserted new assets into DB\n";
        }
    
        $dbh->disconnect;
}
sub getGroups
{
    #print out list of valid owner groups and quit;
    my $dbname = "VULNMGMT_DB";
    my $username = shift;
    my $pwd = shift; 
    my $dbh =  DBI->connect("DBI:mysql:database=$dbname;host=localhost",$username,$pwd, { RaiseError =>1, AutoCommit => 0}) ;
    my $sql = qq/select BUSINESS_UNIT,OwnerID FROM OWNER/;
    my $sth = $dbh->prepare_cached($sql);
    $sth->execute();
    my $href;
    while (my @rows=$sth->fetchrow_array())
    {

      $href->{$rows[0]}=$rows[1];
    }
    $dbh->disconnect;
    return $href;
}
