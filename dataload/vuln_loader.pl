#!/usr/bin/perl -w
#
# Parse CSV file with Qualys vulnerability data and populate asset/vuln tables.
# (Optionally handles Bitsight formtted reports as well (-b option)
#
# Author:  Chris Peters, March 2021
use strict;
use warnings;
use Getopt::Std;
use DBI;
use Text::CSV;
use Data::Dumper;
use constant DEBUG=>0;

our ($opt_b, $opt_i, $opt_u, $opt_p);
getopts("bi:p:u:");
if (!defined($opt_i))
{
        die "Usage: $0 -i<CSV input file>\n";
}

my ($username, $pwd) = ($opt_u, $opt_p);
open my $fh, "<", $opt_i or die "$opt_i: $!";

#1. Parse out Csv FILE
my $csv = Text::CSV->new({binary => 1, auto_diag => 1 });

my $vulnDefs = {}; # need hash of hashes to store vuln defs?

my $first = 0;

if ($opt_b) {
        #that means we have to parse the bitsight data which is in a different format.
        while(my $row = $csv->getline($fh))
        {
            next unless ($first++);   # skip first line with column headers.
            my ($risk,$identifier,$remediation,$status, $assigned, $firstSeen,$lastSeen,$grade, $impacts,
            $remainingLifetime, $attributedTo, $severity,$title,$solution,$comment, $vulnerability, $type, $version, $tags,
            $refresh) = @{$row};
            
            $vulnDefs->{$title}->{threat}=$risk;
            $vulnDefs->{$title}->{impact}="$type $version";
            $vulnDefs->{$title}->{severity}=$severity;
            $vulnDefs->{$title}->{solution}=$solution;
            $vulnDefs->{$title}->{attributedTo}=$attributedTo;
        }
        close $fh;
        print Dumper $vulnDefs if DEBUG;
        loadBitsightData($vulnDefs);
	exit 0;
}
while(my $row = $csv->getline($fh))
{
   next unless ($first++); 
    

    my ($ip, $dns, $netBIOS, $tracking, $os, $ip_status, $qid, $title, $vulnStatus,
        $type, $severity, $port, $protocol, $FQDN, $ssl, $firstDetected, $lastDetected, $timesDetected,
        $dateLastFixed, $CVE, $vendorReference, $bugtraqID, $threat, $impact, $solution, $exploitability,
        $malware, $results,$pciVuln, $ticketState,$instance,$category) = @{$row};
 #   }
        print "Title= $title, $vulnStatus, $type, $severity, $port, $CVE, $threat, $impact\n";
        $vulnDefs->{$qid}->{title}=$title;
        $vulnDefs->{$qid}->{CVE}=$CVE;
        $vulnDefs->{$qid}->{threat}=$threat;
        $vulnDefs->{$qid}->{impact}=$impact;
        $vulnDefs->{$qid}->{severity}=$severity;
        $vulnDefs->{$qid}->{solution}=$solution;
        
}
close $fh;

#print Dumper $vulnDefs if DEBUG;

loadQualysVulnData($vulnDefs);

 

sub loadBitsightData
{
   my $vulnerabilityDefs = shift;
   my $sql_query = qq/insert into VULNERABILITY (VulnerabilityID, Description, Threat, SourceID, SeverityID,  Solution) values (?,?,?,?,?,?)/;
   my $update_query = qq/update VULNERABILITY set LastSeen = ? WHERE VulnerabilityID = ?/;
   my $dbuser = $opt_u;
   my $dbpass = $opt_p;
   my $dbname="VULNMGMT_DB";
   my $dbh = DBI->connect("DBI:mysql:database=$dbname;host=localhost", $dbuser, $dbpass, { RaiseError =>1, AutoCommit => 0}) ;
   my $sth = $dbh->prepare_cached($sql_query);
   my $sth_update = $dbh->prepare_cached($update_query);
   my $newVulnsInserted = 0;
   
   my %severities = ( minor => 1, moderate =>2, material=>3, severe => 4 );
   foreach my $vulnID (keys %{$vulnerabilityDefs})
   {
      
      my $tt = $vulnerabilityDefs->{$vulnID}->{threat};
      my $desc=$vulnerabilityDefs->{$vulnID}->{impact};
      my $fulldescription=$tt;
      if (length($desc) > 1)
      {
	      $fulldescription = "$tt $desc";
      }
    #
    # Need to update the table first to check whether we already have this vulnID
    #
    my $today =`date +%Y-%m-%d`;
    chomp $today;
    print "VulnID = $vulnID\n";
    eval {
         $sth_update->execute($today,$vulnID);
         $dbh->commit;
    };
    if ($@) {
           warn "Trapped database update error: $@\n";
           $dbh->rollback;
    }
    my $rows_updated = $sth_update->rows;
    if ($rows_updated)
    {
            print "Update $rows_updated rows \n";
    } else { # need to insert a new row
         eval {
       		     $sth->execute($vulnID,
                          $vulnerabilityDefs->{$vulnID}->{impact},
			  $fulldescription,
                          2,
                          $severities{$vulnerabilityDefs->{$vulnID}->{severity}},
                          $vulnerabilityDefs->{$vulnID}->{solution});
                    
                        $dbh->commit;
                     $newVulnsInserted++;
       		 };
             if ($@) {
               warn "Trapped database insert error: $@\n";
               $dbh->rollback;
             }      
                               
     }
   }
       
    print "All done:  total new vulns inserted into DB = $newVulnsInserted\n";
    $dbh->disconnect;
        
}

sub loadQualysVulnData
{
# TODO:
# 1.make sure that only active, new or re-opened vulns are reported
# 2. Investigate parsing bug on Description, Solution columns
    my $vulnerabilityDefs = shift;
    my $sql_query = qq/insert into VULNERABILITY (VulnerabilityID, Description, CVE, Threat, SourceID, SeverityID, QualysID, Solution) values (?,?,?,?,?,?,?,?)/;
    my $update_query = qq/update VULNERABILITY set LastSeen = ? WHERE VulnerabilityID = ?/;
    my $dbuser = $opt_u;
    my $dbpass = $opt_p;
    my $dbname="VULNMGMT_DB";
    my $dbh = DBI->connect("DBI:mysql:database=$dbname;host=localhost", $dbuser, $dbpass, { RaiseError =>1, AutoCommit => 0}) ;
    my $sth = $dbh->prepare_cached($sql_query);
    my $sth_update = $dbh->prepare_cached($update_query);

    my $today =`date +%Y-%m-%d`;
    chomp $today;
    
    my %vulnStatus = ( Active => 1, Fixed => 2, New => 3, Reopened => 4);
    my $newVulnsInserted = 0;
    foreach my $vulnID (keys %{$vulnerabilityDefs})
    {
        my $tt = $vulnerabilityDefs->{$vulnID}->{threat};
    #
    # Need to update the table first to check whether we already have this vulnID
    # 
      print "VulnID = $vulnID\n" if DEBUG;
      eval {
         $sth_update->execute($today,$vulnerabilityDefs->{$vulnID}->{title});
         $dbh->commit;
      };
      if ($@) {
           warn "Trapped database update error: $@\n";
           $dbh->rollback;
      }
      my $rows_updated = $sth_update->rows;
      if ($rows_updated)
      {
         print "Update $rows_updated rows \n";
      } else { # need to insert a new row
	      eval {
       		     $sth->execute($vulnerabilityDefs->{$vulnID}->{title},
                          $vulnerabilityDefs->{$vulnID}->{impact},
                          $vulnerabilityDefs->{$vulnID}->{CVE},
                          $vulnerabilityDefs->{$vulnID}->{threat},
                          1,
                          $vulnerabilityDefs->{$vulnID}->{severity},
                          $vulnID,
                          $vulnerabilityDefs->{$vulnID}->{solution}
                          );
	
        		$dbh->commit;
            $newVulnsInserted++;
         };
     	   if ($@) {
       	    warn "Trapped database insert error: $@\n";
            $dbh->rollback;
       	 }
      }
        
    }
    
    print "All done:  total new vulns inserted into DB = $newVulnsInserted\n";
    $sth->finish;
    $sth_update->finish;
    $dbh->disconnect;
}
